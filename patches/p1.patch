diff --git a/gio/gapplicationcommandline.c b/gio/gapplicationcommandline.c
index 78db55b..8f32d6c 100644
--- a/gio/gapplicationcommandline.c
+++ b/gio/gapplicationcommandline.c
@@ -39,6 +39,8 @@
 #include "gwin32inputstream.h"
 #endif
 
+#undef environ
+
 /**
  * GApplicationCommandLine:
  *
diff --git a/gio/gio-tool-mount.c b/gio/gio-tool-mount.c
index 6838775..8930b6c 100644
--- a/gio/gio-tool-mount.c
+++ b/gio/gio-tool-mount.c
@@ -367,7 +367,7 @@ new_mount_op (void)
 
 
 static void
-mount (GFile *file)
+mount_glib (GFile *file)
 {
   GMountOperation *op;
 
@@ -1278,7 +1278,7 @@ handle_mount (int argc, char *argv[], gboolean do_help)
           else if (mount_eject)
             eject (file);
           else
-            mount (file);
+            mount_glib (file);
           g_object_unref (file);
         }
     }
diff --git a/gio/glocalfile.c b/gio/glocalfile.c
index 8b08050..1bdc4a0 100644
--- a/gio/glocalfile.c
+++ b/gio/glocalfile.c
@@ -101,6 +101,7 @@
 #endif
 #endif
 
+#include <dirent.h>
 
 static void g_local_file_file_iface_init (GFileIface *iface);
 
@@ -236,6 +237,31 @@ _g_local_file_new (const char *filename)
   return G_FILE (local);
 }
 
+static  DIR *fdopendir(int fd)
+{
+        DIR *dir;
+        struct stat st;
+
+        if (fstat(fd, &st) < 0) {
+                return 0;
+        }
+        if (fcntl(fd, F_GETFL) & O_PATH) {
+                errno = EBADF;
+                return 0;
+        }
+        if (!S_ISDIR(st.st_mode)) {
+                errno = ENOTDIR;
+                return 0;
+        }
+        if (!(dir = calloc(1, sizeof *dir))) {
+                return 0;
+        }
+
+        fcntl(fd, F_SETFD, FD_CLOEXEC);
+        dir->dd_fd = fd;
+        return dir;
+}
+
 /*< internal >
  * g_local_file_new_from_dirname_and_basename:
  * @dirname: an absolute, canonical directory name
diff --git a/gio/glocalfileinfo.c b/gio/glocalfileinfo.c
index 8d7831f..c24d58a 100644
--- a/gio/glocalfileinfo.c
+++ b/gio/glocalfileinfo.c
@@ -1186,7 +1186,7 @@ lookup_uid_data (uid_t uid)
       if (pwbufp->pw_name != NULL && pwbufp->pw_name[0] != 0)
 	data->user_name = convert_pwd_string_to_utf8 (pwbufp->pw_name);
 
-#ifndef __BIONIC__
+#if !defined(__BIONIC__) && !defined(__MVS__)
       gecos = pwbufp->pw_gecos;
 
       if (gecos)
diff --git a/gio/gmemorymonitorbase.c b/gio/gmemorymonitorbase.c
index ce28ebe..fd14244 100644
--- a/gio/gmemorymonitorbase.c
+++ b/gio/gmemorymonitorbase.c
@@ -29,6 +29,8 @@
 #include "gmemorymonitor.h"
 #include "gmemorymonitorbase.h"
 
+#undef HAVE_SYSINFO
+
 #ifdef HAVE_SYSINFO
 #include <sys/sysinfo.h>
 #endif
diff --git a/gio/gresolver.c b/gio/gresolver.c
index 60fbb4b..2e427a8 100644
--- a/gio/gresolver.c
+++ b/gio/gresolver.c
@@ -41,6 +41,7 @@
 
 #include <stdlib.h>
 
+#include <arpa/inet.h>
 
 /**
  * GResolver:
diff --git a/gio/gsocket.c b/gio/gsocket.c
index 44e9352..8d3d953 100644
--- a/gio/gsocket.c
+++ b/gio/gsocket.c
@@ -82,6 +82,8 @@
 #include "giowin32-afunix.h"
 #endif
 
+#include <xti.h>
+
 /**
  * GSocket:
  *
diff --git a/gio/gthreadedresolver.c b/gio/gthreadedresolver.c
index 988015b..ec45877 100644
--- a/gio/gthreadedresolver.c
+++ b/gio/gthreadedresolver.c
@@ -41,6 +41,8 @@
 #include "gsocketaddress.h"
 #include "gsrvtarget.h"
 
+#undef HAVE_GETIFADDRS
+
 #if HAVE_GETIFADDRS
 #include <ifaddrs.h>
 #endif
diff --git a/gio/gunixmounts.c b/gio/gunixmounts.c
index 009d685..9c70299 100644
--- a/gio/gunixmounts.c
+++ b/gio/gunixmounts.c
@@ -549,7 +549,65 @@ create_unix_mount_point (const char *device_path,
 }
 
 /* mntent.h (Linux, GNU, NSS) {{{2 */
-#ifdef HAVE_MNTENT_H
+#ifdef __MVS__
+
+static char *
+get_mtab_monitor_file (void)
+{
+  /* TODO: Not implemented */
+  return NULL;
+}
+
+static GUnixMountEntry **
+_g_unix_mounts_get_from_file (const char *table_path,
+                              uint64_t   *time_read_out,
+                              size_t     *n_entries_out)
+{
+  /* Not implemented, as per _g_get_unix_mounts() below */
+  if (time_read_out != NULL)
+    *time_read_out = 0;
+  if (n_entries_out != NULL)
+    *n_entries_out = 0;
+
+  return NULL;
+}
+
+static GList *
+_g_get_unix_mounts (void)
+{
+  struct statfs *mntent = NULL;
+  size_t bufsize;
+  int num_mounts, i;
+  GUnixMountEntry *mount_entry;
+  GList *return_list;
+  
+  num_mounts = getmntinfo(&mntent, MNT_NOWAIT);
+  if (num_mounts == -1)
+    return NULL;
+
+  return_list = NULL;
+  
+  for (i = 0; i < num_mounts; i++)
+    {
+      gboolean is_read_only = FALSE;
+
+      if (mntent[i].f_flags & MNT_RDONLY)
+        is_read_only = TRUE;
+
+      mount_entry = create_unix_mount_entry (mntent[i].f_mntfromname,
+                                             mntent[i].f_mntonname,
+                                             NULL,
+                                             mntent[i].f_fstypename,
+                                             NULL,
+                                             is_read_only);
+
+      return_list = g_list_prepend (return_list, mount_entry);
+    }
+  free(mntent);
+  return g_list_reverse (return_list);
+}
+
+#elif HAVE_MNTENT_H
 
 #ifdef HAVE_LIBMOUNT
 
@@ -1176,7 +1234,57 @@ get_fstab_file (void)
 }
 
 /* mntent.h (Linux, GNU, NSS) {{{2 */
-#ifdef HAVE_MNTENT_H
+#ifdef __MVS__
+
+static GList *
+_g_get_unix_mount_points (void)
+{
+  struct statfs *mntent = NULL;
+  size_t bufsize;
+  int num_mounts, i;
+  GUnixMountPoint *mount_point = NULL;
+  GList *return_list;
+
+  num_mounts = getmntinfo(&mntent, MNT_NOWAIT);
+  if (num_mounts == -1)
+    return NULL;
+
+  return_list = NULL;
+
+  for (i = 0; i < num_mounts; i++)
+    {
+      gboolean is_read_only = FALSE;
+
+      if (mntent[i].f_flags & MNT_RDONLY)
+        is_read_only = TRUE;
+
+            mount_point = create_unix_mount_point (mntent[i].f_mntfromname,
+                                             mntent[i].f_mntonname,
+                                             mntent[i].f_fstypename,
+                                             NULL,
+                                             is_read_only,
+                                             FALSE,
+                                             FALSE);
+
+      return_list = g_list_prepend (return_list, mount_point);
+    }
+  free(mntent);
+  return g_list_reverse (return_list);
+}
+
+static GUnixMountPoint **
+_g_unix_mount_points_get_from_file (const char *table_path,
+                                    uint64_t   *time_read_out,
+                                    size_t     *n_points_out)
+{
+  if (time_read_out != NULL)
+    *time_read_out = 0;
+  if (n_points_out != NULL)
+    *n_points_out = 0;
+  return NULL;
+}
+
+#elif HAVE_MNTENT_H
 
 #ifdef HAVE_LIBMOUNT
 
@@ -3834,8 +3942,7 @@ g_unix_mount_point_guess_can_eject (GUnixMountPoint *mount_point)
 }
 
 /* Utility functions {{{1 */
-
-#ifdef HAVE_MNTENT_H
+#if defined(HAVE_MNTENT_H) && !defined(__MVS__)
 /* borrowed from gtk/gtkfilesystemunix.c in GTK on 02/23/2006 */
 static void
 _canonicalize_filename (gchar *filename)
diff --git a/gio/meson.build b/gio/meson.build
index 20a22aa..50cf981 100644
--- a/gio/meson.build
+++ b/gio/meson.build
@@ -776,22 +776,22 @@ install_headers(gio_headers, install_dir : gio_includedir)
 # in PATH, which means you can't bootstrap glib with its own glib-mkenums.
 gioenumtypes_h = custom_target('gioenumtypes_h',
   output : 'gioenumtypes.h',
-  capture : true,
+  capture : false,
   input : gio_headers,
   install : true,
   install_dir : gio_includedir,
   command : [python, glib_mkenums,
              '--template', files('gioenumtypes.h.template'),
-             '@INPUT@', gnetworking_h])
+             '--output', '@OUTPUT@', '@INPUT@', gnetworking_h])
 
 gioenumtypes_c = custom_target('gioenumtypes_c',
   output : 'gioenumtypes.c',
-  capture : true,
+  capture : false,
   input : gio_headers,
   depends : [gioenumtypes_h],
   command : [python, glib_mkenums,
              '--template', files('gioenumtypes.c.template'),
-             '@INPUT@', gnetworking_h])
+             '--output', '@OUTPUT@', '@INPUT@', gnetworking_h])
 
 gioenumtypes_dep = declare_dependency(sources : [gioenumtypes_h, glib_enumtypes_h, gio_visibility_h])
 
diff --git a/gio/tests/gsubprocess-testprog.c b/gio/tests/gsubprocess-testprog.c
index b61ccc2..a7063b2 100644
--- a/gio/tests/gsubprocess-testprog.c
+++ b/gio/tests/gsubprocess-testprog.c
@@ -124,7 +124,7 @@ sleep_forever_mode (int argc,
   return 0;
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(__MVS__)
 #define GLIB_FD_CLOEXEC "e"
 #else
 #define GLIB_FD_CLOEXEC ""
diff --git a/glib/gfileutils.c b/glib/gfileutils.c
index 0855ebe..7d77ba5 100644
--- a/glib/gfileutils.c
+++ b/glib/gfileutils.c
@@ -938,7 +938,7 @@ get_contents_posix (const gchar  *filename,
       FILE *f;
       gboolean retval;
 
-      f = fdopen (fd, "re");
+      f = fdopen (fd, "r");
       
       if (f == NULL)
         {
diff --git a/glib/glib-private.h b/glib/glib-private.h
index 94ea7e8..17cbf33 100644
--- a/glib/glib-private.h
+++ b/glib/glib-private.h
@@ -64,7 +64,7 @@
  * as we'd like: https://stackoverflow.com/a/11529277/210151 and
  * https://devblogs.microsoft.com/oldnewthing/20200731-00/?p=104024
  */
-#elif defined (G_OS_UNIX) && !defined (__APPLE__) && !defined(__CYGWIN__) && !defined(_AIX) && \
+#elif defined (G_OS_UNIX) && !defined (__APPLE__) && !defined(__CYGWIN__) && !defined(_AIX) && !defined(__MVS__) && \
       g_macro__has_attribute (weak)
 
 #define HAS_DYNAMIC_ASAN_LOADING
diff --git a/glib/gutils.c b/glib/gutils.c
index 9c0fbdf..ff1fd9f 100644
--- a/glib/gutils.c
+++ b/glib/gutils.c
@@ -734,7 +734,7 @@ g_get_user_database_entry (void)
           {
             e.user_name = g_strdup (pw->pw_name);
 
-#ifndef __BIONIC__
+#if !defined(__BIONIC__) && !defined(__MVS__)
             if (pw->pw_gecos && *pw->pw_gecos != '\0' && pw->pw_name)
               {
                 gchar **gecos_fields;
diff --git a/glib/tests/include.c b/glib/tests/include.c
index 1325266..29418ab 100644
--- a/glib/tests/include.c
+++ b/glib/tests/include.c
@@ -1,6 +1,6 @@
 /* Test case for bug 659866 */
 
-#define _POSIX_C_SOURCE 199309L
+//#define _POSIX_C_SOURCE 199309L
 #undef _GNU_SOURCE
 #undef _XOPEN_SOURCE
 #include <pthread.h>
diff --git a/glib/tests/thread.c b/glib/tests/thread.c
index ba34485..62bf02b 100644
--- a/glib/tests/thread.c
+++ b/glib/tests/thread.c
@@ -138,7 +138,7 @@ test_thread4 (void)
 {
 #ifdef _GLIB_ADDRESS_SANITIZER
   g_test_incomplete ("FIXME: Leaks a GSystemThread's name, see glib#2308");
-#elif defined(HAVE_PRLIMIT)
+#elif defined(HAVE_PRLIMIT) && defined(RLIMIT_NPROC)
   struct rlimit ol, nl;
   GThread *thread;
   GError *error;
diff --git a/gobject/meson.build b/gobject/meson.build
index 91823af..6470af2 100644
--- a/gobject/meson.build
+++ b/gobject/meson.build
@@ -116,23 +116,23 @@ glib_enumtypes_input_headers = files(
 
 glib_enumtypes_h = custom_target('glib_enumtypes_h',
   output : 'glib-enumtypes.h',
-  capture : true,
+  capture : false,
   input : glib_enumtypes_input_headers,
   install : true,
   install_dir : join_paths(get_option('includedir'), 'glib-2.0/gobject'),
   install_tag: 'devel',
   command : [python, glib_mkenums,
              '--template', files('glib-enumtypes.h.template'),
-             '@INPUT@'])
+             '--output', '@OUTPUT@', '@INPUT@'])
 
 glib_enumtypes_c = custom_target('glib_enumtypes_c',
   output : 'glib-enumtypes.c',
-  capture : true,
+  capture : false,
   input : glib_enumtypes_input_headers,
   depends : [glib_enumtypes_h],
   command : [python, glib_mkenums,
              '--template', files('glib-enumtypes.c.template'),
-             '@INPUT@'])
+             '--output', '@OUTPUT@', '@INPUT@'])
 
 # Expose as variable to be used by gobject-introspection
 # when it includes GLib as a subproject
diff --git a/meson.build b/meson.build
index ba401be..2168bb6 100644
--- a/meson.build
+++ b/meson.build
@@ -18,12 +18,12 @@ fs = import('fs')
 cc = meson.get_compiler('c')
 c_standards = {}
 
-foreach std : ['89', '99', '11', '17']
-  arg = (cc.get_id() == 'msvc' ? '/std:' : '-std=') + 'c' + std
-  if cc.has_argument(arg)
-    c_standards += { std: arg }
-  endif
-endforeach
+#foreach std : ['89', '99', '11', '17']
+#  arg = (cc.get_id() == 'msvc' ? '/std:' : '-std=') + 'c' + std
+#  if cc.has_argument(arg)
+#    c_standards += { std: arg }
+#  endif
+#endforeach
 
 # In the 2.85 cycle, this soft-dependency on C11 will become a hard dependency.
 # If this is a problem on your toolchain or platform, please file an issue
diff --git a/subprojects/libffi.wrap b/subprojects/libffi.wrap
index a8a23bb..65bb85d 100644
--- a/subprojects/libffi.wrap
+++ b/subprojects/libffi.wrap
@@ -3,6 +3,7 @@ directory=libffi
 url=https://gitlab.freedesktop.org/gstreamer/meson-ports/libffi.git
 revision=meson
 depth=1
+diff_files=libffi-patches/zos.patch
 
 [provide]
 libffi = ffi_dep
